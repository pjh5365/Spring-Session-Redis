// 젠킨스 파이프라인 스크립트 (도커와 소스 코드 분리)
pipeline {
    agent any

    environment {
        SSH_PASSWORD = credentials('SSH_PASSWORD')       // Jenkins Credential ID
        PRIVATE_SERVER = 'root@10.0.1.6'                // Private server address
        PEM_PATH = credentials('PEM_PATH')       // Jenkins Credential ID
        APP_PATH = '/app'                              // Application path in container
    }

    stages {
		    // GitLab으로 부터 Pull
        stage('Pull Code from GitLab') {
            steps {
                echo 'Pulling latest code from GitLab...'
                checkout scm
            }
        }
        // Pull 받은 코드 빌드하여 Jar 파일 생성
        stage('Build JAR') {
            steps {
                echo 'Setting execution permission for gradlew...'
                sh 'chmod +x ./gradlew' // 실행 권한 추가
                echo 'Building the JAR file...'
                sh './gradlew clean build -x test' // test를 제외하여 빌드
                sh "cp build/libs/*.jar ${WORKSPACE}/app.jar" // 도커와 볼륨마운트 시킨 경로로 이동
            }
        }
        // Private Subnet으로 접속하여 배포
        stage('Deploy to Private Server') {
            steps {
                echo 'Deploying application to private server...'
                sh '''
                export SSHPASS="${SSH_PASSWORD}"
                sshpass -e ssh -o StrictHostKeyChecking=no -i ${PEM_PATH} ${PRIVATE_SERVER} << EOF
                  docker stop spring-jenkins-app || true
                  docker rm spring-jenkins-app || true
                  docker run -d --name spring-jenkins-app -v ${WORKSPACE}/app.jar:${APP_PATH}/app.jar -p 8080:8080 eclipse-temurin:17-jre java -jar ${APP_PATH}/app.jar
                EOF
                '''
            }
        }
    }

    post {
        always {
            echo 'Pipeline execution completed!'
        }
        success {
            echo 'Pipeline completed successfully!'
        }
        failure {
            echo 'Pipeline failed!'
        }
    }
}
